// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/gzorm/commons/zorm/model"
)

func newLiveRoomCallback(db *gorm.DB, opts ...gen.DOOption) liveRoomCallback {
	_liveRoomCallback := liveRoomCallback{}

	_liveRoomCallback.liveRoomCallbackDo.UseDB(db, opts...)
	_liveRoomCallback.liveRoomCallbackDo.UseModel(&model.LiveRoomCallback{})

	tableName := _liveRoomCallback.liveRoomCallbackDo.TableName()
	_liveRoomCallback.ALL = field.NewAsterisk(tableName)
	_liveRoomCallback.ID = field.NewInt64(tableName, "id")
	_liveRoomCallback.RoomID = field.NewInt64(tableName, "room_id")
	_liveRoomCallback.RoomName = field.NewString(tableName, "room_name")
	_liveRoomCallback.AnchorID = field.NewInt64(tableName, "anchor_id")
	_liveRoomCallback.AnchorNick = field.NewString(tableName, "anchor_nick")
	_liveRoomCallback.AnchorAccount = field.NewString(tableName, "anchor_account")
	_liveRoomCallback.StreamName = field.NewString(tableName, "stream_name")
	_liveRoomCallback.PushDomain = field.NewString(tableName, "pushDomain")
	_liveRoomCallback.IP = field.NewString(tableName, "ip")
	_liveRoomCallback.AppName = field.NewString(tableName, "app_name")
	_liveRoomCallback.ActionAt = field.NewInt64(tableName, "action_at")
	_liveRoomCallback.Usrargs = field.NewString(tableName, "usrargs")
	_liveRoomCallback.CdnNode = field.NewString(tableName, "cdn_node")
	_liveRoomCallback.Height = field.NewField(tableName, "height")
	_liveRoomCallback.Width = field.NewField(tableName, "width")
	_liveRoomCallback.CreateAt = field.NewInt64(tableName, "create_at")

	_liveRoomCallback.fillFieldMap()

	return _liveRoomCallback
}

type liveRoomCallback struct {
	liveRoomCallbackDo

	ALL           field.Asterisk
	ID            field.Int64
	RoomID        field.Int64  // 直播间ID
	RoomName      field.String // 直播间名称
	AnchorID      field.Int64  // 主播序号
	AnchorNick    field.String // 主播昵称
	AnchorAccount field.String // 主播账户
	StreamName    field.String // 推流流名称
	PushDomain    field.String // 推流的域名
	IP            field.String // IP
	AppName       field.String // 推流应用名称
	ActionAt      field.Int64  // 时间戳 单位秒
	Usrargs       field.String // 用户推流的参数
	CdnNode       field.String // CDN接受流的节点或者机器名
	Height        field.Field  // 分辨率高
	Width         field.Field  // 分辨率宽
	CreateAt      field.Int64  // 写入的时间戳

	fieldMap map[string]field.Expr
}

func (l liveRoomCallback) Table(newTableName string) *liveRoomCallback {
	l.liveRoomCallbackDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l liveRoomCallback) As(alias string) *liveRoomCallback {
	l.liveRoomCallbackDo.DO = *(l.liveRoomCallbackDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *liveRoomCallback) updateTableName(table string) *liveRoomCallback {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewInt64(table, "id")
	l.RoomID = field.NewInt64(table, "room_id")
	l.RoomName = field.NewString(table, "room_name")
	l.AnchorID = field.NewInt64(table, "anchor_id")
	l.AnchorNick = field.NewString(table, "anchor_nick")
	l.AnchorAccount = field.NewString(table, "anchor_account")
	l.StreamName = field.NewString(table, "stream_name")
	l.PushDomain = field.NewString(table, "pushDomain")
	l.IP = field.NewString(table, "ip")
	l.AppName = field.NewString(table, "app_name")
	l.ActionAt = field.NewInt64(table, "action_at")
	l.Usrargs = field.NewString(table, "usrargs")
	l.CdnNode = field.NewString(table, "cdn_node")
	l.Height = field.NewField(table, "height")
	l.Width = field.NewField(table, "width")
	l.CreateAt = field.NewInt64(table, "create_at")

	l.fillFieldMap()

	return l
}

func (l *liveRoomCallback) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *liveRoomCallback) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 16)
	l.fieldMap["id"] = l.ID
	l.fieldMap["room_id"] = l.RoomID
	l.fieldMap["room_name"] = l.RoomName
	l.fieldMap["anchor_id"] = l.AnchorID
	l.fieldMap["anchor_nick"] = l.AnchorNick
	l.fieldMap["anchor_account"] = l.AnchorAccount
	l.fieldMap["stream_name"] = l.StreamName
	l.fieldMap["pushDomain"] = l.PushDomain
	l.fieldMap["ip"] = l.IP
	l.fieldMap["app_name"] = l.AppName
	l.fieldMap["action_at"] = l.ActionAt
	l.fieldMap["usrargs"] = l.Usrargs
	l.fieldMap["cdn_node"] = l.CdnNode
	l.fieldMap["height"] = l.Height
	l.fieldMap["width"] = l.Width
	l.fieldMap["create_at"] = l.CreateAt
}

func (l liveRoomCallback) clone(db *gorm.DB) liveRoomCallback {
	l.liveRoomCallbackDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l liveRoomCallback) replaceDB(db *gorm.DB) liveRoomCallback {
	l.liveRoomCallbackDo.ReplaceDB(db)
	return l
}

type liveRoomCallbackDo struct{ gen.DO }

type ILiveRoomCallbackDo interface {
	gen.SubQuery
	Debug() ILiveRoomCallbackDo
	WithContext(ctx context.Context) ILiveRoomCallbackDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ILiveRoomCallbackDo
	WriteDB() ILiveRoomCallbackDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ILiveRoomCallbackDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILiveRoomCallbackDo
	Not(conds ...gen.Condition) ILiveRoomCallbackDo
	Or(conds ...gen.Condition) ILiveRoomCallbackDo
	Select(conds ...field.Expr) ILiveRoomCallbackDo
	Where(conds ...gen.Condition) ILiveRoomCallbackDo
	Order(conds ...field.Expr) ILiveRoomCallbackDo
	Distinct(cols ...field.Expr) ILiveRoomCallbackDo
	Omit(cols ...field.Expr) ILiveRoomCallbackDo
	Join(table schema.Tabler, on ...field.Expr) ILiveRoomCallbackDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILiveRoomCallbackDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILiveRoomCallbackDo
	Group(cols ...field.Expr) ILiveRoomCallbackDo
	Having(conds ...gen.Condition) ILiveRoomCallbackDo
	Limit(limit int) ILiveRoomCallbackDo
	Offset(offset int) ILiveRoomCallbackDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILiveRoomCallbackDo
	Unscoped() ILiveRoomCallbackDo
	Create(values ...*model.LiveRoomCallback) error
	CreateInBatches(values []*model.LiveRoomCallback, batchSize int) error
	Save(values ...*model.LiveRoomCallback) error
	First() (*model.LiveRoomCallback, error)
	Take() (*model.LiveRoomCallback, error)
	Last() (*model.LiveRoomCallback, error)
	Find() ([]*model.LiveRoomCallback, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LiveRoomCallback, err error)
	FindInBatches(result *[]*model.LiveRoomCallback, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.LiveRoomCallback) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILiveRoomCallbackDo
	Assign(attrs ...field.AssignExpr) ILiveRoomCallbackDo
	Joins(fields ...field.RelationField) ILiveRoomCallbackDo
	Preload(fields ...field.RelationField) ILiveRoomCallbackDo
	FirstOrInit() (*model.LiveRoomCallback, error)
	FirstOrCreate() (*model.LiveRoomCallback, error)
	FindByPage(offset int, limit int) (result []*model.LiveRoomCallback, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILiveRoomCallbackDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l liveRoomCallbackDo) Debug() ILiveRoomCallbackDo {
	return l.withDO(l.DO.Debug())
}

func (l liveRoomCallbackDo) WithContext(ctx context.Context) ILiveRoomCallbackDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l liveRoomCallbackDo) ReadDB() ILiveRoomCallbackDo {
	return l.Clauses(dbresolver.Read)
}

func (l liveRoomCallbackDo) WriteDB() ILiveRoomCallbackDo {
	return l.Clauses(dbresolver.Write)
}

func (l liveRoomCallbackDo) Session(config *gorm.Session) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Session(config))
}

func (l liveRoomCallbackDo) Clauses(conds ...clause.Expression) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l liveRoomCallbackDo) Returning(value interface{}, columns ...string) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l liveRoomCallbackDo) Not(conds ...gen.Condition) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l liveRoomCallbackDo) Or(conds ...gen.Condition) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l liveRoomCallbackDo) Select(conds ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l liveRoomCallbackDo) Where(conds ...gen.Condition) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l liveRoomCallbackDo) Order(conds ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l liveRoomCallbackDo) Distinct(cols ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l liveRoomCallbackDo) Omit(cols ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l liveRoomCallbackDo) Join(table schema.Tabler, on ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l liveRoomCallbackDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l liveRoomCallbackDo) RightJoin(table schema.Tabler, on ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l liveRoomCallbackDo) Group(cols ...field.Expr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l liveRoomCallbackDo) Having(conds ...gen.Condition) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l liveRoomCallbackDo) Limit(limit int) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l liveRoomCallbackDo) Offset(offset int) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l liveRoomCallbackDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l liveRoomCallbackDo) Unscoped() ILiveRoomCallbackDo {
	return l.withDO(l.DO.Unscoped())
}

func (l liveRoomCallbackDo) Create(values ...*model.LiveRoomCallback) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l liveRoomCallbackDo) CreateInBatches(values []*model.LiveRoomCallback, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l liveRoomCallbackDo) Save(values ...*model.LiveRoomCallback) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l liveRoomCallbackDo) First() (*model.LiveRoomCallback, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveRoomCallback), nil
	}
}

func (l liveRoomCallbackDo) Take() (*model.LiveRoomCallback, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveRoomCallback), nil
	}
}

func (l liveRoomCallbackDo) Last() (*model.LiveRoomCallback, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveRoomCallback), nil
	}
}

func (l liveRoomCallbackDo) Find() ([]*model.LiveRoomCallback, error) {
	result, err := l.DO.Find()
	return result.([]*model.LiveRoomCallback), err
}

func (l liveRoomCallbackDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LiveRoomCallback, err error) {
	buf := make([]*model.LiveRoomCallback, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l liveRoomCallbackDo) FindInBatches(result *[]*model.LiveRoomCallback, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l liveRoomCallbackDo) Attrs(attrs ...field.AssignExpr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l liveRoomCallbackDo) Assign(attrs ...field.AssignExpr) ILiveRoomCallbackDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l liveRoomCallbackDo) Joins(fields ...field.RelationField) ILiveRoomCallbackDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l liveRoomCallbackDo) Preload(fields ...field.RelationField) ILiveRoomCallbackDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l liveRoomCallbackDo) FirstOrInit() (*model.LiveRoomCallback, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveRoomCallback), nil
	}
}

func (l liveRoomCallbackDo) FirstOrCreate() (*model.LiveRoomCallback, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.LiveRoomCallback), nil
	}
}

func (l liveRoomCallbackDo) FindByPage(offset int, limit int) (result []*model.LiveRoomCallback, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l liveRoomCallbackDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l liveRoomCallbackDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l liveRoomCallbackDo) Delete(models ...*model.LiveRoomCallback) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *liveRoomCallbackDo) withDO(do gen.Dao) *liveRoomCallbackDo {
	l.DO = *do.(*gen.DO)
	return l
}
